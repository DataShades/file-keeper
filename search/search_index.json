{"config":{"lang":["en"],"separator":"[\\s\\-\\.\\_]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting started","text":"<p>file-keeper provides an abstraction layer for storing and retrieving files, supporting various storage backends like local filesystems, cloud storage (S3, GCS), and more.  It simplifies file management by providing a consistent API regardless of the underlying storage.</p>"},{"location":"#installation","title":"Installation","text":"<p>You can install file-keeper using pip:</p> <pre><code>pip install file-keeper\n</code></pre> <p>To use specific storage adapters, you'll need to install extra dependencies. Here's a table of available extras:</p> Storage Type Adapter Name Extras AWS S3 <code>file_keeper:s3</code> <code>s3</code> Apache Libcloud <code>file_keeper:libcloud</code> <code>libcloud</code> Apache OpenDAL <code>file_keeper:opendal</code> <code>opendal</code> Google Cloud Storage <code>file_keeper:gcs</code> <code>gcs</code> Redis <code>file_keeper:redis</code> <code>redis</code> SQLAlchemy <code>file_keeper:sqlalchemy</code> <code>sqlalchemy</code> <p>For example, to install file-keeper with S3 support:</p> <pre><code>pip install 'file-keeper[s3]'\n</code></pre>"},{"location":"#basic-configuration-and-usage-fs-adapter","title":"Basic configuration and usage (FS adapter)","text":"<p>Let's start with a simple example using the local filesystem (FS) adapter.</p> <pre><code>from file_keeper import make_storage, make_upload\n\n# Create a storage instance.  The 'path' setting specifies the root directory\n# for storing files. 'create_path' will automatically create the directory\n# if it doesn't exist.\nstorage = make_storage(\n    \"my_fs_storage\",  # A name for your storage (for logging/debugging)\n    {\n        \"type\": \"file_keeper:fs\",\n        \"path\": \"/tmp/my_filekeeper_files\",\n        \"create_path\": True,\n    },\n)\n\n# Create an upload object from a byte string.\nupload = make_upload(b\"Hello, file-keeper!\")\n\n# Upload the file.  This returns a FileData object containing information\n# about the uploaded file.\nfile_data = storage.upload(\"my_file.txt\", upload)\n\n# Print the file data.\nprint(file_data)\n\n# The file is now stored in /tmp/my_filekeeper_files/my_file.txt\n</code></pre> <p>Explanation:</p> <ul> <li><code>make_storage()</code>: Creates a storage instance with the specified configuration.</li> <li><code>make_upload()</code>: Creates an <code>Upload</code> object from the data you want to store.</li> <li><code>storage.upload()</code>: Uploads the data to the storage.</li> <li><code>FileData</code>:  A dataclass that contains metadata about the uploaded file, including its location, size, content type, and hash.</li> </ul>"},{"location":"#next-steps","title":"Next Steps","text":"<p>This is just a basic example to get you started.  For more detailed information, see the following documentation pages:</p> <ul> <li>Configuration: Learn about all the available settings and how to configure different storage adapters.</li> <li>Storage Adapters:  Explore the different storage adapters supported by file-keeper.</li> </ul>"},{"location":"adapters/","title":"Storage adapters","text":"<pre><code>*   Overview of available adapters.\n*   Table listing adapters with brief descriptions.\n*   Links to individual adapter documentation.\n</code></pre>"},{"location":"adapters/#usage","title":"Usage","text":"TL;DR <pre><code>from file_keeper import make_storage, make_upload, FileData\n\n## DO\nstorage = make_storage(\"sandbox\", {\n    \"type\": \"file_keeper:fs\",\n    \"path\": \"/tmp/file-keeper\",\n    \"create_path\": True,\n})\n\n## OR\nstorage = make_storage(\"sandbox\", {\n    \"type\": \"file_keeper:redis\",\n    \"bucket\": \"file-keeper\"\n})\n\n## OR\nstorage = make_storage(\"sandbox\", {\n    \"type\": \"file_keeper:libcloud\",\n    \"provider\": \"MINIO\",\n    \"params\": {\"host\": \"127.0.0.1\", \"port\": 9000, \"secure\": False},\n    \"key\": \"***\", \"secret\": \"***\",\n    \"container_name\": \"file-keeper\",\n})\n\n## OR\nstorage = make_storage(\"sandbox\", {\n    \"type\": \"file_keeper:s3\",\n    \"endpoint\": \"http://127.0.0.1:9000\",\n    \"key\": \"***\", \"secret\": \"***\",\n    \"bucket\": \"file-keeper\",\n})\n\n\n## THEN\nupload = make_upload(b\"hello world\")\ninfo = storage.upload(\"hello.txt\", upload)\n\ncontent = storage.content(info)\n\ninfo = storage.move(\"moved-hello.txt\", info) # is not supported by libcloud\nstorage.remove(info)\n</code></pre> <p>The main object required for managing files is a storage. Storage initialized using a mapping with settings that contains the type of the underlying adapter. And, depending on the adapter itself, additional options may be required: FS storage needs the path inside the filesystem, while cloud storages would ask you to provide bucket names, secrets, etc.</p> <p>When storage is initialized, it can be used in the same way for every storage adapter.</p> <p>Note</p> <p>The list of operations supported by the storage depends on the adapter. I.e, storage may not support <code>remove</code> or <code>copy</code>, but if it does support the operation, the interface of the operation is identicall accross all storages that support it.</p>"},{"location":"adapters/#local-filesystem","title":"Local filesystem","text":"<p>Let's use the filesystem adapter, which is called <code>file_keeper:fs</code>. This driver requires the <code>path</code> of a root directory where uploaded files are stored. If given path does not exist, the storage will raise an error during initialization. We can either create the directory in advance manually, or enable <code>create_path</code> option of the storage, to automatically add missing folders instead of raising an exception.</p> <p>To initialize the storage, one must call <code>make_storage</code> function, that accepts the name of the storage(used internally for making readable error messages) and the mapping with settings.</p> <pre><code>from file_keeper import make_storage\n\nstorage = make_storage(\"sandbox\", {\n    \"type\": \"file_keeper:fs\",\n    \"path\": \"/tmp/example\",\n    \"create_path\": True,\n})\n</code></pre> <p>Now we need at least one file uploaded into the storage via it's <code>upload</code> method. This method requires the location of the upload and the <code>Upload</code> object with the content. This upload object can be created using <code>make_upload</code> function - just pass bytes, <code>BytesIO</code> or file-like object into it.</p> <pre><code>from file_keeper import make_upload\n\nupload = make_upload(b\"hello world\")\ninfo = storage.upload(\"hello.txt\", upload)\n</code></pre> <p><code>upload</code> method has produced <code>info</code> object of type <code>FileData</code>. This is a dataclass that contains the most essential details about the new upload: location, size, content type and content hash. You need this object to get the file back from the storage.</p> <p>If you don't have such object, but you are sure that there is a file in storage available at the certain location, <code>hello.txt</code> for example, you can build such info object on your own. You don't even need size or content type - just providing the location should be enough:</p> <pre><code>from file_keeper import FileData\n\ninfo = FileData(\"hello.txt\")\n</code></pre> <p>Now, when you have <code>info</code> object, use it to:</p> <ul> <li> <p>read the file</p> <pre><code>content = storage.content(info)\nassert content == b\"hello world\"\n</code></pre> </li> <li> <p>move the file to a new location. Note, this method produces a new <code>info</code>   object that we'll use from now on to access the file. Previous <code>info</code> is no   longer required as it points to non-existing location</p> <pre><code>info = storage.move(\"moved-hello.txt\", info)\n</code></pre> </li> <li> <p>remove the file</p> <pre><code>storage.remove(info)\n</code></pre> </li> </ul> <p>If you want to use a different storage adapter, initialize a different storage. All other operations remain the same.</p>"},{"location":"adapters/#redis","title":"Redis","text":"<p>Let's try Redis storage, which is available if you installed file-keeper with <code>redis</code> extras:</p> <pre><code>pip install 'file-keeper[redis]'\n</code></pre> <p>The adapter is called <code>file_keeper:redis</code>. It expects Redis DB to be available at <code>redis://localhost:6379/0</code>(which can be changed via <code>url</code> option). And it also requires <code>bucket</code> option, but here it will be used as a name of HASH where all the files are stored Redis.</p> <pre><code>from file_keeper import make_storage, make_upload\n\nstorage = make_storage(\"sandbox\", {\n    \"type\": \"file_keeper:redis\",\n    \"bucket\": \"files-from-file-keeper\"\n})\n\nupload = make_upload(b\"hello world\")\n\ninfo = storage.upload(\"hello.txt\", upload)\nassert info.size == 11\n\ncontent = storage.content(info)\nassert content == b\"hello world\"\n\nstorage.remove(info)\n# method that checks whether the file exists in the storage\nassert not storage.exists(info)\n</code></pre>"},{"location":"adapters/#cloud","title":"Cloud","text":"<p>Finally, let's check cloud storage. There are multiple options, but we'll use Apache Libcloud adapter. To make it available, install file-keeper with <code>libcloud</code> extras:</p> <pre><code>pip install 'file-keeper[libcloud]'\n</code></pre> <p>The adapter is called <code>file_keeper:libcloud</code>. Unlike previous adapters, it has a lot of options and majority of them are required:</p> <ul> <li><code>provider</code>: name of Apache Libcloud   provider</li> <li><code>params</code>: mapping with additional parameters specific for the chosen provider</li> <li><code>key</code>: access key for the cloud storage</li> <li><code>secret</code>: access secret for the cloud storage</li> <li><code>container_name</code>: name of the container/bucket where files are stored</li> </ul> <p>Requirements regarding this options are not the same for different storage providers. We'll use <code>MINIO</code> provider(because it's free). For this example, we assume that MINIO is running locally, on 9000 port, without SSL. You can create a Docker container using the command below:</p> <pre><code>docker run -p 9000:9000 -p 9001:9001 \\\n    --name minio -e MINIO_PUBLIC_ADDRESS=0.0.0.0:9000 \\\n    quay.io/minio/minio server /data --console-address \":9001\"\n</code></pre> <p>Details about this local MinIO service will be encoded into <code>params</code> option: <code>{\"host\": \"127.0.0.1\", \"port\": 9000, \"secure\": False}</code>.</p> <p>Create MinIO credentials using WebUI available at http://127.0.0.1:9001 and add them as <code>key</code> and <code>secret</code> options.</p> <p>Finally, create a bucket <code>file-keeper</code> and specify it using <code>container_name</code> option.</p> <p>That's how initialization will look when all preparations are done:</p> <pre><code>storage = make_storage(\"sandbox\", {\n    \"type\": \"file_keeper:libcloud\",\n    \"provider\": \"MINIO\",\n    \"params\": {\"host\": \"127.0.0.1\", \"port\": 9000, \"secure\": False},\n    \"key\": \"***\",\n    \"secret\": \"***\",\n    \"container_name\": \"file-keeper\",\n})\n</code></pre> <p>Note</p> <p><code>file_keeper:libcloud</code> adapter does not support <code>move</code> operation and you'll see an exception upon calling <code>storage.move</code>.</p> <p>Instead of using <code>file_keeper:libcloud</code>, you can try <code>file_keeper:s3</code> adapter that relies on boto3 and is available when file-keeper is installed with <code>s3</code> extras:</p> <pre><code>pip install 'file-keeper[s3]'\n</code></pre> <p>Unlike <code>file_keeper:libcloud</code>, <code>s3</code> adapter works only with AWS S3(and MinIO that has identical API). But it supports wider list of storage operations, so it worth using it if you know that you are not going to use different cloud provider.</p> <p>Initialization is slighly different for <code>file_keeper:s3</code>:</p> <ul> <li>use <code>bucket</code> instead of <code>container_name</code></li> <li>add <code>endpoint</code> that combines <code>params.host</code> and <code>params.port</code> from <code>file_keeper:libcloud</code></li> </ul> <pre><code>from file_keeper import make_storage\n\nstorage = make_storage(\"sandbox\", {\n    \"type\": \"file_keeper:s3\",\n    \"endpoint\": \"http://127.0.0.1:9000\",\n    \"key\": \"***\",\n    \"secret\": \"***\",\n    \"bucket\": \"file-keeper\",\n})\n</code></pre> <p>With <code>file_keeper:s3</code> you can use <code>move</code> and can replicate all operations used in previous examples.</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#unreleased","title":"[unreleased]","text":"<p>Compare with v0.0.10</p>"},{"location":"changelog/#features","title":"\ud83d\ude80 Features","text":"<ul> <li>[breaking] frozen FileData and MultipartData (cb9dbf8)</li> <li>less strict typing rules for storage settings (247d1c6)</li> <li>remove str from exceptions (2ecd8a2)</li> <li>add memory storage (3abc218)</li> <li>storage.ext.register accepts optional <code>reset</code> parameter (c5edce8)</li> <li>Settings log extra options with debug level instead of raising an exception (7308578)</li> <li>add null storage (c1f8476)</li> </ul>"},{"location":"changelog/#bug-fixes","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>storage settings keep a lot of intermediate parameters (cf69cf2)</li> <li>libcloud silently overrides existing objects (599f099)</li> </ul>"},{"location":"changelog/#v0010-2025-07-13","title":"v0.0.10 - 2025-07-13","text":"<p>Compare with v0.0.9</p>"},{"location":"changelog/#features_1","title":"\ud83d\ude80 Features","text":"<ul> <li>add public_prefix(and permanent_link) to libcloud (3bc7591)</li> <li>static_uuid transformer (88383e0)</li> <li>location transformers receive optional upload-or-data second argument (8e6a6dc)</li> </ul>"},{"location":"changelog/#bug-fixes_1","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>fix_extension transformer raises an error when upload is missing (a827df5)</li> </ul>"},{"location":"changelog/#removal","title":"\u274c Removal","text":"<ul> <li>delete Storage.public_link (da08744)</li> </ul>"},{"location":"changelog/#v009-2025-07-02","title":"v0.0.9 - 2025-07-02","text":"<p>Compare with v0.0.8</p>"},{"location":"changelog/#features_2","title":"\ud83d\ude80 Features","text":"<ul> <li>add fix_extension transformer (1345915)</li> <li>opendal got path option (d044ade)</li> </ul>"},{"location":"changelog/#bug-fixes_2","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>cast fs:multipart:position to int (dc4d768)</li> </ul>"},{"location":"changelog/#v008-2025-04-23","title":"v0.0.8 - 2025-04-23","text":"<p>Compare with v0.0.7</p>"},{"location":"changelog/#features_3","title":"\ud83d\ude80 Features","text":"<ul> <li>libcloud storage got path option (555036c)</li> </ul>"},{"location":"changelog/#bug-fixes_3","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>fs storage reports relative location of the missing file (cef9589)</li> </ul>"},{"location":"changelog/#v007-2025-03-28","title":"v0.0.7 - 2025-03-28","text":"<p>Compare with v0.0.6</p>"},{"location":"changelog/#features_4","title":"\ud83d\ude80 Features","text":"<ul> <li>storage upload and append requires Upload (ebf5fef)</li> </ul>"},{"location":"changelog/#bug-fixes_4","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>fs storage checks permission when creating folders (1791d68)</li> </ul>"},{"location":"changelog/#v006-2025-03-23","title":"v0.0.6 - 2025-03-23","text":"<p>Compare with v0.0.4</p>"},{"location":"changelog/#features_5","title":"\ud83d\ude80 Features","text":"<ul> <li>add *_synthetic methods (27c4164)</li> </ul>"},{"location":"changelog/#bug-fixes_5","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>multipart update of s3 and gcs work with arbitrary upload (902c9cb)</li> </ul>"},{"location":"changelog/#v004-2025-03-22","title":"v0.0.4 - 2025-03-22","text":"<p>Compare with v0.0.3</p>"},{"location":"changelog/#features_6","title":"\ud83d\ude80 Features","text":"<ul> <li>storages accept any type of upload (a64ee3d)</li> </ul>"},{"location":"changelog/#refactor","title":"\ud83d\ude9c Refactor","text":"<ul> <li>remove validation from storage (93392f9)</li> <li>remove type and size validation from append and compose (890c89a)</li> <li>remove public link method and capability (cb39151)</li> </ul>"},{"location":"changelog/#removal_1","title":"\u274c Removal","text":"<ul> <li>drop link storage (3328eb2)</li> </ul>"},{"location":"changelog/#v002-2025-03-17","title":"v0.0.2 - 2025-03-17","text":"<p>Compare with v0.0.1</p>"},{"location":"changelog/#features_7","title":"\ud83d\ude80 Features","text":"<ul> <li>stream-based composite implementation of range (7d47bd8)</li> <li>add Location wrapper around unsafe path parameters (b99f155)</li> <li>file_keeper:opendal adapter (214fb6c)</li> <li>file_keeper:redis adapter (8c7da94)</li> </ul>"},{"location":"changelog/#bug-fixes_6","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>map error during settings initialization into custom exception (f596037)</li> <li>fs adapter: infer <code>uploaded</code> size if it is not specified in <code>multipart_update</code> (620ec3a)</li> </ul>"},{"location":"changelog/#refactor_1","title":"\ud83d\ude9c Refactor","text":"<ul> <li><code>location_strategy: str</code> become <code>location_transformers: list[str]</code> (daf2dc6)</li> <li>remove default range implementation from reader (36f5f31)</li> </ul>"},{"location":"changelog/#testing","title":"\ud83e\uddea Testing","text":"<ul> <li>add standard adapter tests (d961682)</li> </ul>"},{"location":"changelog/#v001-2025-03-13","title":"v0.0.1 - 2025-03-13","text":""},{"location":"configuration/","title":"Configuration","text":"<p>file-keeper's behavior is highly configurable through the <code>Settings</code> class. This page details the available settings and how to use them to customize your storage setup.</p>"},{"location":"configuration/#the-settings-class","title":"The <code>Settings</code> Class","text":"<p>The <code>Settings</code> class is the central point for configuring each storage adapter. It defines the options that control how the adapter interacts with the underlying storage.  Each adapter has its own subclass of <code>Settings</code> that adds adapter-specific options.</p> <p>While you can directly instantiate a <code>Settings</code> subclass with its arguments, the most common approach is to pass a dictionary of options to the storage adapter constructor. file-keeper automatically handles the transformation of this dictionary into a <code>Settings</code> object. This provides a more flexible and user-friendly configuration experience.</p> <p>How it Works:</p> <ol> <li>You provide a dictionary containing the configuration options for the     storage adapter.</li> <li>file-keeper's <code>make_storage</code> function (or the adapter's constructor     directly) uses the <code>SettingsFactory</code> associated with the adapter to create     a <code>Settings</code> object from the dictionary.</li> <li>The <code>SettingsFactory.from_dict()</code> method handles the conversion, including     validation and handling of any unexpected options.  Any unrecognized     options are stored in the <code>_extra_settings</code> attribute for later use if     needed.</li> </ol> <p>Example:</p> <p>Let's say you want to configure the S3 adapter. Instead of creating a <code>Settings</code> object directly, you can simply pass a dictionary like this:</p> <pre><code>from file_keeper import make_storage\n\ns3_settings = {\n    \"type\": \"file_keeper:s3\",\n    \"bucket\": \"my-s3-bucket\",\n    \"key\": \"YOUR_AWS_ACCESS_KEY_ID\",\n    \"secret\": \"YOUR_AWS_SECRET_ACCESS_KEY\",\n    \"region\": \"us-east-1\",\n    \"extra_option\": \"some_value\",  # This will be stored in _extra_settings\n}\n\nstorage = make_storage(\"my_s3_storage\", s3_settings)\n\n# Accessing the settings (for demonstration)\nprint(storage.settings.bucket)  # Output: my-s3-bucket\nprint(storage.settings._extra_settings.get(\"extra_option\"))  # Output: some_value\n</code></pre> <p>In this example, <code>make_storage</code> automatically creates a <code>Settings</code> object from the <code>s3_settings</code> dictionary.  The <code>extra_option</code> is stored in the <code>_extra_settings</code> dictionary, allowing you to access it if needed.</p> <p>Benefits of using a dictionary:</p> <ul> <li>Flexibility: Easily pass configuration options from environment     variables, configuration files, or other sources.</li> <li>Readability: Dictionaries are often more concise and easier to read     than creating <code>Settings</code> objects directly.</li> <li>Extensibility: Allows you to pass custom options that are not     explicitly defined in the <code>Settings</code> class.</li> </ul>"},{"location":"configuration/#common-settings","title":"Common Settings","text":"<p>These settings are available for most storage adapters:</p> <ul> <li><code>override_existing</code> (bool, default: <code>False</code>): If <code>True</code>, existing files     will be overwritten during upload. If <code>False</code> (the default), an     <code>ExistingFileError</code> will be raised if a file with the same location already     exists.</li> <li><code>path</code> (str, required for most adapters): The base path or directory     where files are stored.  The exact meaning of this setting depends on the     adapter (e.g., a path in the filesystem for the FS adapter, a prefix-path     inside the bucket for S3).</li> <li><code>location_transformers</code> (list[str], default: <code>[]</code>): A list of names of     location transformers to apply to file locations.  These transformers can     be used to sanitize or modify file paths before they are used to store     files.  See the Extending file-keeper documentation for     details on creating custom location transformers.</li> <li><code>disabled_capabilities</code> (list[str], default: <code>[]</code>): A list of     capabilities to disable for the storage adapter. This can be useful for     limiting the functionality of an adapter or for testing purposes.</li> </ul>"},{"location":"configuration/#adapter-specific-settings","title":"Adapter-Specific Settings","text":"<p>In addition to the common settings, each adapter has its own specific settings:</p>"},{"location":"configuration/#file_keeperfs","title":"<code>file_keeper:fs</code>","text":"<ul> <li><code>create_path</code> (bool, default: <code>False</code>): If <code>True</code>, the <code>path</code> directory     will be created if it doesn't exist. If <code>False</code>, an     <code>InvalidStorageConfigurationError</code> will be raised if the <code>path</code> directory     doesn't exist.</li> </ul>"},{"location":"configuration/#file_keeperlibcloud","title":"<code>file_keeper:libcloud</code>","text":"<ul> <li><code>container_name</code> (str, required): The name of the cloud container to use.</li> <li><code>key</code> (str): The access key.</li> <li><code>secret</code> (str): The secret access key.</li> <li><code>provider</code> (str): apache-libcloud storage provider.</li> <li><code>params</code> (str): JSON object with additional parameters passed directly to storage constructor.</li> </ul>"},{"location":"configuration/#file_keepers3","title":"<code>file_keeper:s3</code>","text":"<ul> <li><code>bucket</code> (str): The name of the S3 bucket to use.</li> <li><code>key</code> (str): The AWS access key ID.  If not provided, the AWS     credentials will be loaded from the environment or the AWS configuration     file.</li> <li><code>secret</code> (str): The AWS secret access key.  If not provided, the AWS     credentials will be loaded from the environment or the AWS configuration     file.</li> <li><code>region</code> (str): The AWS region to use.  If not provided, the AWS     credentials will be used to determine the region.</li> <li><code>endpoint</code> (str): The S3 endpoint URL.  This can be used to connect to     a custom S3-compatible storage service.</li> </ul>"},{"location":"configuration/#gcs-adapter","title":"GCS Adapter","text":"<ul> <li><code>bucket</code> (str): The name of the GCS bucket to use.</li> <li><code>credentials_file</code> (str): The path to the Google Cloud service account credentials file. If not provided, the credentials will be loaded from the environment.</li> </ul>"},{"location":"configuration/#configuration-examples","title":"Configuration Examples","text":"<p>Here are some examples of how to configure different storage adapters:</p> <p>FS Adapter:</p> <pre><code>settings = {\n    \"type\": \"file_keeper:fs\",\n    \"path\": \"/tmp/my_files\",\n    \"create_path\": True,\n}\n</code></pre> <p>S3 Adapter:</p> <pre><code>settings = {\n    \"type\": \"file_keeper:s3\",\n    \"bucket\": \"my-s3-bucket\",\n    \"key\": \"YOUR_AWS_ACCESS_KEY_ID\",\n    \"secret\": \"YOUR_AWS_SECRET_ACCESS_KEY\",\n    \"region\": \"us-east-1\",\n}\n</code></pre> <p>GCS Adapter:</p> <pre><code>settings = {\n    \"type\": \"file_keeper:gcs\",\n    \"bucket\": \"my-gcs-bucket\",\n    \"credentials_file\": \"/path/to/your/credentials.json\",\n}\n</code></pre>"},{"location":"configuration/#using-settingsfrom_dict","title":"Using <code>Settings.from_dict()</code>","text":"<p>The <code>Settings.from_dict()</code> method provides a convenient way to create a <code>Settings</code> object from a dictionary. It also handles validation and provides a way to pass in extra settings that are not defined in the <code>Settings</code> class.</p> <pre><code>from file_keeper.default.adapters.fs import Settings\n\nsettings_data = {\n    \"path\": \"/tmp/my_files\",\n    \"create_path\": True,\n    \"extra_setting\": \"some_value\",  # This will be stored in settings._extra_settings\n}\n\nsettings = Settings.from_dict(settings_data)\n\nprint(settings.path)  # Output: /tmp/my_files\nprint(settings._extra_settings[\"extra_setting\"])  # Output: some_value\n</code></pre>"},{"location":"configuration/#important-considerations","title":"Important Considerations","text":"<ul> <li>Security:  Be careful when storing sensitive information like AWS access keys and secret keys in your configuration.  Consider using environment variables or a secure configuration management system.</li> <li>Validation:  file-keeper performs some basic validation of the configuration settings, but it's important to ensure that your settings are correct for your specific storage adapter.</li> <li>Error Handling:  Be prepared to handle <code>InvalidStorageConfigurationError</code> exceptions if your configuration is invalid.</li> </ul>"},{"location":"error_handling/","title":"Error Handling","text":"<p>file-keeper provides a comprehensive set of exceptions to help you handle errors gracefully. This page documents the available exceptions and provides guidance on how to handle them.</p>"},{"location":"error_handling/#general-exception-hierarchy","title":"General Exception Hierarchy","text":"<p>All exceptions in file-keeper inherit from the base <code>FilesError</code> exception.  This allows you to catch all file-keeper related errors with a single <code>except</code> block.  More specific exceptions are derived from <code>FilesError</code> to provide more detailed error information.</p>"},{"location":"error_handling/#specific-exceptions","title":"Specific Exceptions","text":""},{"location":"error_handling/#fileserror","title":"<code>FilesError</code>","text":"<ul> <li>Description: Base class for all file-keeper exceptions.</li> <li>When it's raised:  Generally, you won't catch this directly. It's the parent class for more specific exceptions.</li> <li>How to handle:  Catch more specific exceptions whenever possible.</li> </ul>"},{"location":"error_handling/#storageerror","title":"<code>StorageError</code>","text":"<ul> <li>Description: Base class for exceptions related to storage operations.</li> <li>When it's raised:  When a general storage-related error occurs.</li> <li>How to handle:  Catch more specific exceptions derived from <code>StorageError</code>.</li> </ul>"},{"location":"error_handling/#unknownstorageerror","title":"<code>UnknownStorageError</code>","text":"<ul> <li>Description: Raised when a storage with the specified name is not configured.</li> <li>When it's raised:  When you try to use a storage that hasn't been registered.</li> <li>How to handle:  Verify that the storage is configured correctly.</li> </ul>"},{"location":"error_handling/#unknownadaptererror","title":"<code>UnknownAdapterError</code>","text":"<ul> <li>Description: Raised when a specified storage adapter is not registered.</li> <li>When it's raised:  When you try to use an adapter that isn't supported.</li> <li>How to handle:  Check the adapter name and ensure it's valid.</li> </ul>"},{"location":"error_handling/#unsupportedoperationerror","title":"<code>UnsupportedOperationError</code>","text":"<ul> <li>Description: Raised when a requested operation is not supported by the storage.</li> <li>When it's raised:  When you try to perform an operation that the storage doesn't support.</li> <li>How to handle:  Check the storage's capabilities using <code>storage.supports()</code> before attempting the operation.</li> </ul>"},{"location":"error_handling/#permissionerror","title":"<code>PermissionError</code>","text":"<ul> <li>Description: Raised when the storage client does not have the required permissions.</li> <li>When it's raised:  When the storage client lacks the necessary permissions to perform an operation.</li> <li>How to handle:  Verify that the storage client has the correct permissions.</li> </ul>"},{"location":"error_handling/#locationerror","title":"<code>LocationError</code>","text":"<ul> <li>Description: Raised when the storage cannot use the given location (e.g., invalid path).</li> <li>When it's raised:  When the location is invalid or inaccessible.</li> <li>How to handle:  Verify that the location is valid and accessible.</li> </ul>"},{"location":"error_handling/#missingfileerror","title":"<code>MissingFileError</code>","text":"<ul> <li>Description: Raised when a file does not exist.</li> <li>When it's raised:  When you try to access a file that doesn't exist.</li> <li>How to handle:  Check if the file exists before attempting to access it.</li> </ul>"},{"location":"error_handling/#existingfileerror","title":"<code>ExistingFileError</code>","text":"<ul> <li>Description: Raised when a file already exists and overwriting is not allowed.</li> <li>When it's raised:  When you try to upload a file that already exists and <code>override_existing</code> is set to <code>False</code>.</li> <li>How to handle:  Either set <code>override_existing</code> to <code>True</code> or choose a different location.</li> </ul>"},{"location":"error_handling/#extraserror","title":"<code>ExtrasError</code>","text":"<ul> <li>Description: Raised when incorrect extra parameters are passed to a storage method.</li> <li>When it's raised:  When a required extra parameter is missing or invalid.</li> <li>How to handle:  Verify that you are passing the correct extra parameters.</li> </ul>"},{"location":"error_handling/#missingextraserror","title":"<code>MissingExtrasError</code>","text":"<ul> <li>Description: Raised when a required extra parameter is missing.</li> <li>When it's raised:  When a required extra parameter is not provided.</li> <li>How to handle:  Provide the missing extra parameter.</li> </ul>"},{"location":"error_handling/#invalidstorageconfigurationerror","title":"<code>InvalidStorageConfigurationError</code>","text":"<ul> <li>Description: Raised when the storage cannot be initialized with the given configuration.</li> <li>When it's raised:  When the storage configuration is invalid.</li> <li>How to handle:  Verify that the storage configuration is correct.</li> </ul>"},{"location":"error_handling/#uploaderror","title":"<code>UploadError</code>","text":"<ul> <li>Description: Base class for exceptions related to file uploads.</li> <li>When it's raised:  When a general upload-related error occurs.</li> <li>How to handle:  Catch more specific exceptions derived from <code>UploadError</code>.</li> </ul>"},{"location":"error_handling/#uploadoutofbounderror","title":"<code>UploadOutOfBoundError</code>","text":"<ul> <li>Description: Raised when a multipart upload exceeds the expected size.</li> <li>When it's raised:  When the uploaded data is larger than the expected size.</li> <li>How to handle:  Verify that the upload size is correct.</li> </ul>"},{"location":"error_handling/#uploadmismatcherror","title":"<code>UploadMismatchError</code>","text":"<ul> <li>Description: Raised when the expected value of a file attribute (e.g., content type, hash) does not match the actual value.</li> <li>When it's raised:  When there is a mismatch between the expected and actual file attributes.</li> <li>How to handle:  Verify that the file attributes are correct.</li> </ul>"},{"location":"error_handling/#uploadtypemismatcherror","title":"<code>UploadTypeMismatchError</code>","text":"<ul> <li>Description: Raised when the expected content type does not match the actual content type.</li> <li>When it's raised:  When the content type is incorrect.</li> <li>How to handle:  Verify that the content type is correct.</li> </ul>"},{"location":"error_handling/#uploadhashmismatcherror","title":"<code>UploadHashMismatchError</code>","text":"<ul> <li>Description: Raised when the expected hash does not match the actual hash.</li> <li>When it's raised:  When the file hash is incorrect.</li> <li>How to handle:  Verify that the file hash is correct.</li> </ul>"},{"location":"error_handling/#uploadsizemismatcherror","title":"<code>UploadSizeMismatchError</code>","text":"<ul> <li>Description: Raised when the expected file size does not match the actual file size.</li> <li>When it's raised:  When the file size is incorrect.</li> <li>How to handle:  Verify that the file size is correct.</li> </ul>"},{"location":"error_handling/#example-error-handling","title":"Example Error Handling","text":"<pre><code>from file_keeper import make_storage, make_upload\nfrom file_keeper.core import exceptions\n\ntry:\n    storage = make_storage(\"my_storage\", {\"type\": \"file_keeper:fs\", \"path\": \"/nonexistent/path\"})\n    upload = make_upload(b\"Hello, file-keeper!\")\n    storage.upload(\"my_file.txt\", upload)\nexcept exceptions.InvalidStorageConfigurationError as e:\n    print(f\"Error configuring storage: {e}\")\nexcept exceptions.MissingFileError as e:\n    print(f\"File not found: {e}\")\nexcept exceptions.StorageError as e:\n    print(f\"A general storage error occurred: {e}\")\nexcept Exception as e:\n    print(f\"An unexpected error occurred: {e}\")\n</code></pre>"},{"location":"extending/","title":"Extending file-keeper","text":"<pre><code>*   How to create custom storage adapters.\n*   How to create custom upload factories.\n*   How to create custom location transformers.\n*   Example code snippets.\n</code></pre>"},{"location":"core_concepts/capabilities/","title":"Capabilities","text":"<pre><code>*   Explanation of the `Capability` enum.\n*   How to check if a storage supports a specific operation.\n*   Examples of using capabilities.\n</code></pre>"},{"location":"core_concepts/data_model/","title":"Data model","text":"<pre><code>*   Explanation of `FileData`, `MultipartData`, `Location`.\n*   Attributes of each class.\n*   How these classes are used in different operations.\n</code></pre>"},{"location":"core_concepts/uploads/","title":"Upload","text":"<pre><code>*   Explanation of the `Upload` class.\n*   How to create an `Upload` object.\n*   Streaming uploads.\n*   Hashing.\n</code></pre>"}]}